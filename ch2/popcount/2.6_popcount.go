// 实现了位计数函数, 用来统计一个uint64(8个字节)数值中有多少个比特位是1
// 例如输入15, 输出4, 代表有4个bit置1

package popcount

// 声明一个256个字节的数组, 每个元素都是uint8, 0~255
// 这是一个查表数组, 提前把, 一个字节中有多少个1, 放到
var pc [265]byte

// 初始化这个表
// 提前计算好每个字节中包含多少个1
// 0   00000000  有0个1 | 1   00000001   有1个1 | 2    00000010   有1个1
// 5   00000101  有2个1
// 255 11111111  有8个1
func init() {
	// 遍历pc数组的所有索引(0-255)
	for i := range pc {
		// 这是一个递推公式
		// i/2相当于i右移一位(去掉最低位)
		// i&1 判断最低位是不是1
		// 所以, i的置1个数=i>>1的个数+当前最低位是不是1
		/* 举例
			i=5 -> 0101
			5/2 -> 右移1位, 010 pc[2]
			5&1=1 最低位是1, 加1
		    递归 pc[2]
			i=2 -> 010
			2/2 -> 右移1位, 01 pc[1]
			2&1=0 最低位是0
			递归 pc[1]
			i=1 -> 01
			1/2 -> 右移1位, 0 pc[0]
			1&1=1 最低位是1, 加1
			直接返回
			记录下来: pc[5]=2
		*/
		// 索引0-255, 代表1个byte字节值
		// value, 代表这个字节值对应有几个1
		pc[i] = pc[i/2] + byte(i&1)

	}
}

func PopCount(x uint64) int {
	// 把x分成8段
	// 右移0个段, byte取, 相当于取出倒数第一段
	// 右移1个段, byte取, 相当于取出倒数第二段
	// 右移2个段, byte取, 相当于取出倒数第三段
	// ...
	// 右移7个段, byte取, 相当于取出正数第一段
	// byte取出来是字节值, pc[byte(...)], 返回这个字节值有几个1

	return int(pc[byte(x>>(0*8))] + // x=0xF0F0F0F0F0F0F0F0  不移位    byte(...)  取出最低的8位是F0  F0对应的字节值是240  pc[240]=4
		pc[byte(x>>(1*8))] + // x=0xF0F0F0F0F0F0F0F0  右移8位   byte(...)  取出最低的8位是F0  F0对应的字节值是240  pc[240]=4
		pc[byte(x>>(2*8))] +
		pc[byte(x>>(3*8))] +
		pc[byte(x>>(4*8))] +
		pc[byte(x>>(5*8))] +
		pc[byte(x>>(6*8))] +
		pc[byte(x>>(7*8))])
}

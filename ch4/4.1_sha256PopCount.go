// 计算两个SHA256哈希码中不同bit的数目
package main

import (
	"crypto/sha256"
)

// 数组，索引0-255，初值都是0000 0000. pc1是计算0-255, 里面有多少个1
// pc0是计算0-255, 里面有多少个1
var pc1, pc0 [256]byte

// 遍历pc, i拿到的是索引, 第一个=0, 第二个=1, 第三个=2, ... 最后一个=255
// 要计算每个索引值, 有几个1. pc数组的索引是0~255, pc数组的值:索引0里面有几个1, ... 索引255有几个1

func init() {

	for i, _ := range pc1 {
		// 这是一个递推公式
		// i=0 0000 i>>1 是000 pc[0000]=0; i&1=0 pc[0000]=0+0=0
		// i=1 0001 i>>1 是000 pc[0000]=0; i&1=1 pc[0001]=0+1=1
		// i=2 0010 i>>1 是001 pc[0001]=1; i&1=0 pc[0010]=1+0=1 从现在开始递推上一个
		// i=3 0011 i>>1 是001 pc[0001]=1; i&1=1 pc[0011]=1+1=2
		// i=4 0100 i>>1 是010 pc[0010]=1; i&1=0 pc[0100]=1+0=1
		// i=5 0101 i>>1 是010 pc[0010]=1; i&1=1 pc[0101]=1+1=2
		// ...
		pc1[i] = pc1[i/2] + byte(i&1)
		pc0[i] = 8 - pc1[i]
	}

}

// sha256是256bit, 256/8=32, 返回一个数组, 里面有32个byte元素, 每个元素都是一个字节值
// 我的pc是一个数组, 里面是256个byte元素, 记录每个索引0-255, 有几个1
func convshaPopcount(s string) (int, int) {
	// c1的类型[32]byte
	// c的值有可能是:2d 71 16 42 b7 26 b0 44 01 62 7c a9 fb ac 32 f5 c8 53 0f b1 90 3c c4 db 02 25 87 17 92 1a 48 81
	// c的值一共是32个byte, 拿到的v是一个byte, 例如2d
	// pc1[2d]的value,就是有几个1,  0010 1110 一共4个1, pc1[2d]=4, 4的类型是byte, 要转换成int, 做加法
	c := sha256.Sum256([]byte(s))
	sum1, sum0 := 0, 0

	for _, v := range c {
		// 遍历c,不要索引只要值, pc1[值], 等价于这个值在pc1对应的索引, 有几个1, 做累加
		sum1 += int(pc1[v])
		sum0 += int(pc0[v])
	}
	return sum1, sum0

}
